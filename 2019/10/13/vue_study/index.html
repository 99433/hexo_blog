<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta name="keywords" content="前端最好用的框架-Vue, Vue javascript jquery nodejs php">
  <meta name="description" content="1、前端三大框架angular(google)—-react(facebook)—–vue（尤雨溪）
2014年发布，2016年升级2.0
Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架
Vue.js ">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="renderer" content="webkit|ie-stand|ie-comp">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="format-detection" content="telephone=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>前端最好用的框架-Vue | Wang peng&#39;s blog</title>
  <link rel="icon" type="image/png" href="/hexo_blog/favicon.png">

  <link rel="stylesheet" type="text/css" href="/hexo_blog/libs/awesome/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="/hexo_blog/libs/materialize/css/materialize.min.css">
  <link rel="stylesheet" type="text/css" href="/hexo_blog/libs/aos/aos.css">
  <link rel="stylesheet" type="text/css" href="/hexo_blog/libs/animate/animate.min.css">
  <link rel="stylesheet" type="text/css" href="/hexo_blog/libs/lightGallery/css/lightgallery.min.css">
  <link rel="stylesheet" type="text/css" href="/hexo_blog/css/matery.css">
  <link rel="stylesheet" type="text/css" href="/hexo_blog/css/my.css">
  <style type="text/css">
    
  </style>

  <script src="/hexo_blog/libs/jquery/jquery-2.2.0.min.js"></script>
</head>

<body>

  <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="container">
            <div class="nav-wrapper">
                <div class="brand-logo">
                    <a href="/hexo_blog/" class="waves-effect waves-light">
                        
                        <img src="/hexo_blog/medias/logo.png" class="logo-img hide-on-small-only">
                        
                        <span class="logo-span">Wang peng's blog</span>
                    </a>
                </div>
                

<a href="#" data-activates="mobile-nav" class="button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/hexo_blog/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/hexo_blog/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/hexo_blog/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/hexo_blog/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/hexo_blog/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/hexo_blog/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a id="toggleSearch" class="waves-effect waves-light">
            <i id="searchIcon" class="mdi-action-search" title="搜索"></i>
        </a>
    </li>

</ul>

<div class="side-nav" id="mobile-nav">

    <div class="mobile-head bg-color">
        
        <img src="/hexo_blog/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Wang peng's blog</div>
        <div class="logo-desc">
            
            分享前端技术知识点和学习的博客站
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/hexo_blog/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/hexo_blog/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/hexo_blog/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/hexo_blog/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/hexo_blog/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/hexo_blog/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/yanyufanchen" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>yanyufanchen
            </a>
        </li>
        
    </ul>

    <div class="social-link">
    <a href="https://github.com/yanyufanchen" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:592394158@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=592394158" class="tooltipped" data-tooltip="QQ联系我: 592394158" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


</div>
</div>

            </div>
        </div>

        
        <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/yanyufanchen" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="yanyufanchen" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>
</header>

  



<div class="bg-cover post-cover" style="background-image: url('/hexo_blog/images/vue.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        前端最好用的框架-Vue
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/hexo_blog/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }
</style>
<div class="row">
    <div class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/hexo_blog/tags/Vue/" target="_blank">
                                <span class="chip bg-color">Vue</span>
                            </a>
                        
                            <a href="/hexo_blog/tags/框架/" target="_blank">
                                <span class="chip bg-color">框架</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/hexo_blog/categories/前端开发/" class="post-category" target="_blank">
                                前端开发
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-10-13
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        7.9k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        35 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h4 id="1、前端三大框架"><a href="#1、前端三大框架" class="headerlink" title="1、前端三大框架"></a>1、前端三大框架</h4><p>angular(google)—-react(facebook)—–vue（尤雨溪）</p>
<p>2014年发布，2016年升级2.0</p>
<p>Vue (读音 /vjuː/，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式框架</strong></p>
<p>Vue.js 是构建 Web 界面的 <a href="https://baike.baidu.com/item/JavaScript" target="_blank" rel="noopener">JavaScript</a> 库</p>
<h4 id="2、vue-指令"><a href="#2、vue-指令" class="headerlink" title="2、vue-指令"></a>2、vue-指令</h4><h5 id="1、v-cloak"><a href="#1、v-cloak" class="headerlink" title="1、v-cloak"></a>1、v-cloak</h5><p>​    插值表达式存在的问题：“闪动”   (页面上会短暂显示例如的vue语法字符串)</p>
<p>​    如何解决该问题：使用v-cloak指令 (先设置属性css,display:none,然后添加到标签上)</p>
<p>​    解决该问题的原理：先隐藏，替换好值之后再显示最终的值</p>
<h5 id="2、v-text-填充纯文本"><a href="#2、v-text-填充纯文本" class="headerlink" title="2、v-text   填充纯文本"></a>2、v-text   填充纯文本</h5><h5 id="3、-v-html-可以填充标签语法"><a href="#3、-v-html-可以填充标签语法" class="headerlink" title="3、 v-html    可以填充标签语法"></a>3、 v-html    可以填充标签语法</h5><p>​        存在安全问题</p>
<p>​        本网站内部数据可以使用，来自第三方的数据不可以用</p>
<h5 id="4、-v-pre"><a href="#4、-v-pre" class="headerlink" title="4、 v-pre"></a>4、 v-pre</h5><p>​    让vue语法跳过编译，直接暴露vue语法  如：</p>
<pre><code class="javascript">&lt;div id=&#39;app&#39; v-html=&quot;msg3&quot;&gt;//指令会直接替换里面的语法
        {{msg}}
    &lt;/div&gt;
    &lt;script type=&#39;text/javascript&#39;&gt;
        var vm = new Vue({
            el: &#39;#app&#39;,
            data: {
                msg: &#39;Hello Vue&#39;,
                msg1: &#39;Hdasda&#39;,
                msg3: &#39;&lt;img src=&quot;./img/apple.png&quot; alt=&quot;&quot;&gt;&#39;
            }
        });
    &lt;/script&gt;</code></pre>
<h5 id="5、v-once-只编译一次"><a href="#5、v-once-只编译一次" class="headerlink" title="5、v-once 只编译一次"></a>5、v-once 只编译一次</h5><p>（数据响应式，就是数据的改变，会导致页面内容发生变化，而v-once就是让内容显示之后，就不再发生数据响应式）</p>
<h5 id="6、v-if"><a href="#6、v-if" class="headerlink" title="6、v-if"></a>6、v-if</h5><p>放在标签中，则满足条件的才进行渲染</p>
<pre><code>&lt;li v-if=&quot;id&lt;3&quot;&gt;{{id}}&lt;/li&gt;</code></pre><p>因为 <code>v-if</code> 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 <code>&lt;template&gt;</code> 元素当做不可见的包裹元素，并在上面使用 <code>v-if</code>。最终的渲染结果将不包含 <code>&lt;template&gt;</code> 元素</p>
<pre><code class="javascript">&lt;template v-if=&quot;ok&quot;&gt;
  &lt;h1&gt;Title&lt;/h1&gt;
  &lt;p&gt;Paragraph 1&lt;/p&gt;
  &lt;p&gt;Paragraph 2&lt;/p&gt;
&lt;/template&gt;</code></pre>
<p><code>v-else</code> 元素必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素的后面，否则它将不会被识别。</p>
<p>key—————————————–</p>
<p>所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 <code>key</code> 属性即可：</p>
<pre><code>&lt;template v-if=&quot;loginType === &#39;username&#39;&quot;&gt;
  &lt;label&gt;Username&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;
&lt;/template&gt;
&lt;template v-else&gt;
  &lt;label&gt;Email&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;
&lt;/template&gt;</code></pre><h5 id="7、v-show-显示和隐藏"><a href="#7、v-show-显示和隐藏" class="headerlink" title="7、v-show   显示和隐藏"></a>7、v-show   显示和隐藏</h5><p>不同的是带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code> 只是简单地切换元素的 CSS 属性 <code>display</code>。</p>
<p>注意，<code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</p>
<pre><code>&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</code></pre><h5 id="v-if和v-show-的区别"><a href="#v-if和v-show-的区别" class="headerlink" title="v-if和v-show 的区别"></a>v-if和v-show 的区别</h5><p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>
<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p>
<h5 id="8、v-bind-动态的给元素绑定属性"><a href="#8、v-bind-动态的给元素绑定属性" class="headerlink" title="8、v-bind:动态的给元素绑定属性"></a>8、<code>v-bind</code>:动态的给元素绑定属性</h5><pre><code>new Vue({
    el:&#39;#app&#39;,
    data:{
        url:&#39;http://www.baidu.com/&#39;,
        attributeName:&quot;href&quot;
    }
})

&lt;a v-bind:href = &#39;url&#39;&gt;百度&lt;/a&gt;
&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;</code></pre><h5 id="9、v-for-循环结构"><a href="#9、v-for-循环结构" class="headerlink" title="9、v-for    循环结构"></a>9、v-for    循环结构</h5><p>​    遍历数组——————————</p>
<pre><code class="javascript">&lt;ul&gt;
&lt;li v-for=&quot;(item,index) in arr&quot; :key=&quot;item.name&quot;&gt;{{item.id}}---{{item.name}}----{{i}}&lt;&gt;
&lt;/ul&gt;
arr:[
  {
    id:1,
    name:&#39;jack1&#39;
  },{
    id:2,
    name:&#39;jack2&#39;
  },
  {
    id:3,
    name:&#39;jack3&#39;
  }
]
</code></pre>
<p>​    遍历对象</p>
<pre><code>&lt;div v-for=&#39;(value,key,index) in object&#39;&gt;{{value+'-'+key+'-'+i}}&lt;/div&gt;
&lt;div v-if=&#39;value&#39; v-for=&#39;(value,key,index) in object&#39;&gt;{{value+'-'+key+'-'+i}}&lt;/div&gt;</code></pre><h4 id="3-Vue模板语法"><a href="#3-Vue模板语法" class="headerlink" title="3.Vue模板语法"></a>3.Vue模板语法</h4><h5 id="1、v-model双向数据绑定"><a href="#1、v-model双向数据绑定" class="headerlink" title="1、v-model双向数据绑定"></a>1、v-model双向数据绑定</h5><p>​    数据发生变化，页面内容发生变化，相反页面内容发生变化，数据也发生变化   （数据劫持）</p>
<pre><code>&lt;!-- v-model 指令只能用于表单元素和组件 常见于input/textarea/select标签上 --&gt;
&lt;input type=&#39;text&#39; v-model=&#39;uname&#39;/&gt;
&lt;div id=&#39;app&#39;&gt;
        username: &lt;input type=&quot;text&quot; v-model=&#39;user&#39; /&gt; &lt;br&gt;  
        用户名是:{{user}}
    &lt;/div&gt;
    &lt;script type=&#39;text/javascript&#39;&gt;
        var vm = new Vue({
            el: &#39;#app&#39;,
            data: {
                user: &#39;请输入用户名&#39;,           
            }
        });
    &lt;/script&gt;</code></pre><p>表单域修饰符</p>
<p>v-model.number=’age’//默认获取的input值是字符串，number可以转化为数值</p>
<p>v-model.trim  :去掉开始和结尾的空格</p>
<p>v-model.lazy =”username” ,将input事件切换为change事件  </p>
<p>//也就是说，默认input输入框的值变化，就触发input事件来实现username的值变化，加了lazy后，就是，触发change事件来实现username的值得变化</p>
<pre><code class="javascript">&lt;input type=&quot;&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; v-model.lazy=&quot;username&quot; @input=&quot;&quot; @change=&quot;change&quot;/&gt;
        &lt;span&gt;{{username}}&lt;/span&gt;  //触发change事件时，username才更改

在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步：

&lt;!-- 在“change”时而非“input”时更新 --&gt;
&lt;input v-model.lazy=&quot;msg&quot; &gt;</code></pre>
<h5 id="2、MVVM设计思想"><a href="#2、MVVM设计思想" class="headerlink" title="2、MVVM设计思想"></a>2、MVVM设计思想</h5><p>​        M(model)  模型层   var vm=new Vue()</p>
<p>​        V(view)    视图     html</p>
<p>​        VM(View-Model)    逻辑层      vm对象内的逻辑层</p>
<p>​        View(Dom)==&gt;View-Model(vue)==&gt;model</p>
<p>​        View(Dom)&lt;==View-Model(vue)&lt;==model</p>
<h5 id="3、v-on-事件绑定"><a href="#3、v-on-事件绑定" class="headerlink" title="3、v-on:/@事件绑定"></a>3、v-on:/@事件绑定</h5><pre><code class="javascript">事件函数的调用方式
    直接绑定函数名称
    &lt;button v-on:click=&#39;say&#39;&gt;Hello&lt;/button&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {
        num: 222
      },
      methods: {
        say: function(){
          // 这里的this是Vue的实例对象+
          console.log(this.num)
        }
      }
    });
  &lt;/script&gt;</code></pre>
<p>​    （1）事件修饰符   </p>
<p>​        v-on:click.prevent=’say’    //阻止默认行为</p>
<p>​        v-on:click.stop=’say’    //阻止冒泡</p>
<p>​    （2）按键修饰符</p>
<p>​         v-on:keyup.enter=’submit’ 回车事件</p>
<p>​        v-on:keyup.delete=’handle’  触发delete键</p>
<p>​        keyup 键盘弹起事件</p>
<p>​    （3）change 状态改变事件</p>
<p>​        v-on 可以用@替代</p>
<p>​    4、属性绑定   v-bind:src=”url”    url是变量名  </p>
<p>​        作用就是，让浏览器把url当成变量解析，否则会当字符串解析</p>
<pre><code class="javascript">&lt;img v-bind:src=&quot;url&quot; alt=&quot;&quot;&gt;   //全称
&lt;img :src=&quot;url&quot; alt=&quot;&quot;&gt;            //简写
&lt;div id=&#39;app&#39;&gt;
        &lt;img v-bind:src=&quot;url&quot; alt=&quot;&quot;&gt;
    &lt;/div&gt;
    &lt;script type=&#39;text/javascript&#39;&gt;
        var vm = new Vue({
            el: &#39;#app&#39;,
            data: {
                url: &quot;./img/lemon.png&quot;
            }
        });
    &lt;/script&gt;</code></pre>
<p>​    v-model的底层实现原理</p>
<pre><code>&lt;input v-bind:value=&quot;msg&quot; v-on:input=&quot;msg=$event.target.value&quot;&gt;
绑定value属性， 当input事件触发时，将value值赋值给变量，然后把变量显示在页面上  由于value绑定了，当变量值变化时，value值也会同步变化</code></pre><h5 id="4、样式绑定"><a href="#4、样式绑定" class="headerlink" title="4、样式绑定"></a>4、样式绑定</h5><h5 id="1、class样式处理"><a href="#1、class样式处理" class="headerlink" title="1、class样式处理"></a>1、class样式处理</h5><pre><code class="javascript">(1)&lt;div v-bind:class&quot;{active:isActive}&quot;&gt;&lt;/div&gt;    //第一种写法
    //isActive=true,代表有这个类名，false代表没有这个类名
    //this.isActive=!this.isActive 可以用来切换类名
(2) &lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;  //第二种写法
(3) 两者可以结合使用
&lt;div v-bind:class=&quot;[activeClass, errorClass，{active:isActive}]&quot;&gt;&lt;/div
还可以使用三元表达式方式切换类
&lt;div v-bind:class=&quot;[activeClass, errorClass，flag?&#39;c&#39;:&#39;&#39;]&quot;&gt;&lt;/div&gt;
flag=false/true 之间切换，可以改变类</code></pre>
<h5 id="2、style内联样式"><a href="#2、style内联样式" class="headerlink" title="2、style内联样式"></a>2、style内联样式</h5><p>​            直接在元素上通过 <code>:style</code> 的形式，书写样式对象</p>
<pre><code>&lt;h1 :style=&quot;{color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;}&quot;&gt;这是一个善良的H1&lt;/h1&gt;</code></pre><p>​            给元素的 style传递一个对象，对象包含样式参数</p>
<pre><code>&lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt;
data: {
        h1StyleObj: { color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; }
}</code></pre><p>​            给元素的style传递一个数组，数组中可以包含多个对象</p>
<pre><code>&lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt;
data: {
        h1StyleObj: { color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; },
        h1StyleObj2: { fontStyle: &#39;italic&#39; }
}</code></pre><h4 id="4、自定义指令directive"><a href="#4、自定义指令directive" class="headerlink" title="4、自定义指令directive"></a>4、自定义指令directive</h4><p>​    1、语法规则（全局）</p>
<pre><code>
// 注册一个全局自定义指令 `v-focus`
Vue.directive(&#39;focus&#39;, {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
      //el就是获取到的被绑定的元素(DOM元素 )
    // 聚焦元素
    el.focus()
  }
})</code></pre><pre><code>&lt;div id=&#39;app&#39;&gt;
        {{msg}}
        &lt;p v-a=&quot;y&quot;&gt;qq&lt;/p&gt;
    &lt;/div&gt;

    Vue.directive(&#39;a&#39;,{
            bind:function(el,binding){ //钩子函数的参数
                console.log(el);
                console.log(binding);
            }
        })
钩子函数  bind和inserted
bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
// el 是指令所在的元素对象
// bingding是一个对象
// binding.value //指令等号后面表达式的值 也就是变量的值
// binding.expression // 指令等号后面的表达式  本质就是一个变量
</code></pre><p>​    2、自定义私有指令</p>
<p>如果想注册局部指令，组件中也接受一个 <code>directives</code> 的选项：</p>
<pre><code class="JavaScript">var vm = new Vue({
            el: &#39;#app&#39;,
            data: {
                msg: &#39;Hello Vue&#39;,
                y:&#39;red&#39;
            }，
            directives: {      //在
                  focus: {   
                // 指令的定义
                    inserted: function (el) {
                          el.focus()
                    }
                  }
            }
        });</code></pre>
<p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> 属性，如下：</p>
<pre><code>&lt;input v-focus&gt;</code></pre><h4 id="5、过滤器"><a href="#5、过滤器" class="headerlink" title="5、过滤器"></a>5、过滤器</h4><h5 id="1、自定义过滤器filter"><a href="#1、自定义过滤器filter" class="headerlink" title="1、自定义过滤器filter"></a>1、自定义过滤器filter</h5><blockquote>
<p>在数据展示之前,对原始数据进行处理并返回处理后的数据进行展示,不改变原始数据</p>
</blockquote>
<blockquote>
<p>过滤器只能用在插值表达式和属性绑定(v-bind)中</p>
</blockquote>
<pre><code class="javascript">//全局过滤器
Vue.filter(&#39;过滤器名称&#39;,function(data,arg){
    // data是原始数据,即管道符前面的数据
    // arg 是使用过滤器时传递的参数
    // 1. 对原始数据进行逻辑处理
    // 2. 处理完成后进行return
    return `处理完的数据`
})
&lt;div&gt;{{原始数据 | 过滤器名称(参数)}}&lt;/div&gt;</code></pre>
<pre><code class="javascript">Vue.filter(&#39;upder&#39;,function(data,arg){
    return data.trim()   //data就是msg   arg是传参,可以传几个参数
})
msg=&#39;   222   &#39;
&lt;div&gt;{{msg | upder}}&lt;/div&gt; //得到的msg=&gt;&#39;222&#39;
相当于把msg放入过滤器函数中执行处理函数，然后返回新的msg值
过滤器也可以传参数
&lt;div&gt;{{msg | upder(aaa)}}&lt;/div&gt; //得到的msg=&gt;&#39;222&#39;</code></pre>
<p>局部自定义过滤器</p>
<pre><code>&lt;div&gt;{{msg | aa(aaa)}}&lt;/div&gt; //得到的msg=&gt;&#39;222&#39;
var vm = new Vue({
            el: &#39;#app&#39;,
            data: {
                msg: &#39;Hello Vue&#39;,
            }，
            filters: {      
                aa(data,reg){
                       return data.trim() 
                }    
            }
        });</code></pre><h4 id="6、计算属性computed"><a href="#6、计算属性computed" class="headerlink" title="6、计算属性computed"></a>6、计算属性computed</h4><p>​    用于定义一种可以随着所依赖数据发生变化的属性</p>
<p>对于任何复杂逻辑，你都应当使用<strong>计算属性</strong></p>
<pre><code class="javascript">&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;f1&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;f2&quot;&gt;
    &lt;span&gt;{{a}}&lt;/span&gt;
&lt;/div&gt;
new Vue({
    el:&#39;#app&#39;,
    // data中定义普通属性
    data:{
           f1:1,
           f2:2,
           f:0
    },
    // compluted中定义的函数名就是计算属性 属性的值是该函数的返回值
    // 计算属性的值会随着依赖数据的变化而变化
    // 例如this.msg被修改 则comMsg的值也会重新计算
    compluted:{
        a(){
            return Number(this.f1)*Number(this.f2)
        }
    }
})
computed  ====&gt;浏览器运行就会执行，只要有函数的属性发生变化，就会再次调用</code></pre>
<p>计算属性和计算方法</p>
<p>computed计算属性   基于之前的缓存，如果不发生变化，是不再次计算</p>
<p>​                    计算的属性来源于data中的属性，属性发生变化就再次调用</p>
<p>methord计算方法      这里就没有缓存，每次调用都会进行计算</p>
<h4 id="7、侦听器-watch"><a href="#7、侦听器-watch" class="headerlink" title="7、侦听器 watch"></a>7、侦听器 watch</h4><p>​    //浏览器运行，里面的函数不会执行，也就是函数名的值发生变化，就会执行</p>
<pre><code>&lt;div id=&#39;app&#39;&gt;
        {{msg}}
        first&lt;input type=&quot;&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; v-model=&quot;first&quot; /&gt;
        last&lt;input type=&quot;&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; v-model=&quot;last&quot; /&gt;
        姓名{{aa}}
    &lt;/div&gt;
    &lt;script type=&#39;text/javascript&#39;&gt;
        var vm = new Vue({
            el: &#39;#app&#39;,
            data: {
                msg: &#39;Hello Vue&#39;,
                aa:&#39;wangpeng&#39;,
                first:&quot;wang&quot;,
                last:&quot;peng&quot;,
            },
            watch:{
                first(newval,oldval){   //first的值改变,就执行这个函数,然后值赋值给aa，因为是双向绑定，也就是input值变，就执行这个函数
                函数会有缓存，oldval记录上一次的值，newval是当前变化后的值
                    this.aa=this.first+this.last
                    // this.aa=val+this.last
                },
                last(val){   //first的值改变,就执行这个函数,然后值赋值给aa
                    this.aa=this.first+this.last
                    // this.aa=this.first+val
                }
            }
        });
    &lt;/script&gt;</code></pre><h4 id="8、生命周期"><a href="#8、生命周期" class="headerlink" title="8、生命周期"></a>8、生命周期</h4><p>​    阶段</p>
<p>挂载（初始化相关属性）—更新（元素或组件的变更操作）—销毁（销毁相关属性）</p>
<p>—————–挂载—————–和methods同级别的加载函数</p>
<p>1、beforeCreate函数//在这个阶段，data中的数据和methods中的函数都没加载完就执行了函数,</p>
<p>2、created/beforeMount/mounted函数//在这个阶段，data中的数据和methods中的函数加载完了就执行了函数，</p>
<p>3、created加载时，dom结构还没加载完（重点）</p>
<p>4、deforeMount加载时，dom结构加载完了，但是动态数据还没解析</p>
<p>5、mounted加载时，dom结构加载完，数据已解析//相当于window.onload（重点）</p>
<h4 id="9、数组相关API"><a href="#9、数组相关API" class="headerlink" title="9、数组相关API"></a>9、数组相关API</h4><p>1、变异方法(修改原有数据)push() pop() shift() unshift() splice() sort() reverse()</p>
<ol start="2">
<li>替换数组(生成新的数组)filter()concat()slice()</li>
<li>修改响应式数据Vue.set(vm.items, indexOfItem, newValue)vm.$set(vm.items, indexOfItem, newValue)参数一表示要处理的数组名称参数二表示要处理的数组的索引参数三表示要处理的数组的值</li>
</ol>
<h4 id="10、组件化component"><a href="#10、组件化component" class="headerlink" title="10、组件化component"></a>10、组件化component</h4><h5 id="1、全局组件创建–调用"><a href="#1、全局组件创建–调用" class="headerlink" title="1、全局组件创建–调用"></a>1、全局组件创建–调用</h5><pre><code class="javascript">&lt;btn-counter&gt;&lt;/btn-counter&gt;  //调用
//注册  组件名建议小写，如果使用驼峰命名，大写会报错，不能用关键字
Vue.component(&#39;btn-counter&#39;,{  
  data:function(){
    return {
      count:0   //模板中需要使用的参数
    }
  },
  //template模板只能有一个外层标签 
  template:&#39;&lt;button @click=&#39;add&#39;&gt;点击了{{count}}&lt;/button&gt;&#39;, 
  methods:{
    add(){
      count++
    }
  }
})</code></pre>
<pre><code class="javascript">模板可以采用ES6的模板字符串`****`  ,这种方式适用于结构复杂的模板结构
template:`&lt;div&gt;
    &lt;button @click=&quot;add&quot;&gt;点击了{{count}}次&lt;/button&gt;
    &lt;button @click=&quot;add&quot;&gt;点击了{{count}}次&lt;/button&gt;
&lt;/div&gt;`</code></pre>
<h5 id="2、局部组件创建–注册—调用"><a href="#2、局部组件创建–注册—调用" class="headerlink" title="2、局部组件创建–注册—调用"></a>2、局部组件创建–注册—调用</h5><p>//其中data必须是一个函数，里面写一个return对象，其中包含值</p>
<pre><code class="javascript">var hello-world={  //定义组件
  data(){    
    return{
      msg:&#39;hello&#39;
    }
  },
  template:&quot;&lt;div&gt;{{msg}}&lt;/div&gt;&quot;
}
//在里面注册
var vm = new Vue({
            el: &#39;#app&#39;,
            data: {

            },
            components:{ //注册
              hello-world
            }</code></pre>
<h5 id="3、父组件向子组件传值"><a href="#3、父组件向子组件传值" class="headerlink" title="3、父组件向子组件传值"></a>3、父组件向子组件传值</h5><p>实现原理：通过在父属性中调用来获取值，然后传递给自己的props,再传到模板template，然后模板渲染在页面上</p>
<pre><code> &lt;div id=&#39;app&#39;&gt;
      &lt;father :aa=&quot;msg&quot; :bb=&quot;msg2&quot;&gt;&lt;/father&gt; //在vm组件中调用father子组件
    &lt;/div&gt; 
    -------------------------------------
 var  father={  //vm的子组件
            template:&quot;&lt;div&gt;这是一个father组件==={{aa}}=={{bb}}  &lt;son :bb=&#39;ft&#39;&gt;&lt;/son&gt;&lt;/div&gt;&quot;,
            data(){
                return  {
                }
            },
            methods:{},
            props:[&quot;aa&quot;,&quot;bb&quot;]  //值通过调用组件时获取,然后传给当前的模板
        }
        ---------------------------------
 var vm = new Vue({   //vm父组件
            el: &#39;#app&#39;,
            data: {
                msg: &#39;Hello Vue&#39;, //要传递的值
                msg2: &#39;Hello world&#39;,
            },
            components:{
                father:father //注册子组件
            }
        });
</code></pre><h5 id="4、子组件向父组件传递值"><a href="#4、子组件向父组件传递值" class="headerlink" title="4、子组件向父组件传递值"></a>4、子组件向父组件传递值</h5><p>​    实现原理：子组件dom绑定实例事件，触发普通函数来条用$emit来触发传入的自定义事件，然后调用的子组件上绑定了这个自定义事件，并传值，自定义事件被触发，立即调用父组件的普通函数，父组件获取到了传递的值，赋值保存。</p>
<pre><code class="javascript">&lt;div id=&#39;app&#39;&gt;  //调用vm的子组件
        &lt;father :aa=&quot;msg&quot; @event_get=&quot;show&quot;&gt;&lt;/father&gt;  
        //绑定自定义事件 监听子组件的事件
    &lt;/div&gt;
    &lt;script &gt; 
        var father={ //定义内置组件
          data(){
            return{
              str:&#39;子组件向父组件传递参数&#39;
            }
          }
          template:&quot;&lt;button @click=&#39;get&#39;&gt;点击&lt;/button&gt;&quot;, 
          //当点击这个div，就触发get函数，
        methods:{
        //触发get，然后$emit()自动触发事件event_get，而调用的时候，这个事件绑定了vm组件的show函数，于是执行show函数，并传递一个子组件的参数给show

        //同时子组件可以通过调用内建的 $emit 方法 并传入事件名称来触发一个事件：
          get(){  
            this.$emit(&#39;event_get&#39;,this.str)
          }
        }
        }
        var vm=new Vue(
            {
              el:&#39;#app&#39;,
              data:{
                app:&quot;&quot;
              },
              methods:{
                show(mes){
                  this.app=mes  //将获取的值赋值给当前组件的属性，存起来，可用于使用这个传递过来的值
                }
              }
            }
        )
    &lt;/script &gt;</code></pre>
<h5 id="5、兄弟组件之间数据传递"><a href="#5、兄弟组件之间数据传递" class="headerlink" title="5、兄弟组件之间数据传递"></a>5、兄弟组件之间数据传递</h5><pre><code>//定义事件中心
var eventHub=new Vue()
var a={  
  template:&quot;&lt;div @click=&quot;aa&quot;&gt;a组件&lt;/div&gt;&quot;, //绑定一个事件函数
  data(){
    return {
      num_a:&#39;&#39;
    }
  },
  methods:{
    aa(){
      eventHub.$emit(&#39;a_b&#39;,&quot;这是a传递的值&quot;)  //触发事件a_b
    }
  }
}
var b={  
  template:&quot;&lt;div &gt;b组件===={{str_b}}&lt;/div&gt;&quot;, //绑定一个事件函数
  data(){
    return{
      str_b:&#39;&#39;
    }
  },
  mounted(){
    eventHub.$on(&#39;a_b&#39;,(mes)=&gt;{    //监听事件a_b
      this.str_b=mes   //将a触发事件传递给b的监听事件
    })
  }
}
var vm = new Vue({
            el: &#39;#app&#39;,
            data: {
                msg: &#39;Hello Vue&#39;,
                app:&quot;&quot;
            },
            components:{
                father:father
            },
            methods:{
                show(message){
                    this.app=message;
                    console.log(message,1111)

                }
            }
        });</code></pre><h4 id="11、插槽"><a href="#11、插槽" class="headerlink" title="11、插槽"></a>11、插槽</h4><h5 id="1、插槽创建"><a href="#1、插槽创建" class="headerlink" title="1、插槽创建"></a>1、插槽创建</h5><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;alert-box&gt;有bug发生&lt;/alert-box&gt;
  &lt;/div&gt;
  Vue.component(&#39;alert-box&#39;, {
      template: `
        &lt;div&gt;
          &lt;strong&gt;ERROR:&lt;/strong&gt;
          &lt;slot&gt;默认内容&lt;/slot&gt;    //将上面的内容替换掉slot，显示在页面上
        &lt;/div&gt;
      `
    });
    var vm = new Vue({
      el: &#39;#app&#39;,
      data: {
      }
    });</code></pre><h5 id="2、具名插槽"><a href="#2、具名插槽" class="headerlink" title="2、具名插槽"></a>2、具名插槽</h5><pre><code class="javascript">就是利用&lt;slot&gt;元素的name属性，来定义专属的插槽，
不待name的&lt;slot&gt; 是通用的
&lt;div id=&quot;app&quot;&gt;
    &lt;base-layout&gt;
  //自动将指定的盒子内容放入header的slot插槽中   不一定需要template包裹
      &lt;template slot=&#39;header&#39;&gt;    
        &lt;p&gt;标题信息1&lt;/p&gt;
        &lt;p&gt;标题信息2&lt;/p&gt;
      &lt;/template&gt;
      &lt;p&gt;主要内容1&lt;/p&gt;   //此处的内容默认放入没有name的slot卡槽中
      &lt;p&gt;主要内容2&lt;/p&gt;
      &lt;template slot=&#39;footer&#39;&gt;  //自动将指定的模板放入footer的slot插槽中
        &lt;p&gt;底部信息信息1&lt;/p&gt;
        &lt;p&gt;底部信息信息2&lt;/p&gt;
      &lt;/template&gt;
    &lt;/base-layout&gt;
  &lt;/div&gt;
//组件------------
 Vue.component(&#39;base-layout&#39;, {
      template: `
        &lt;div&gt;
          &lt;header&gt;
            &lt;slot name=&#39;header&#39;&gt;&lt;/slot&gt;   //给&lt;slot&gt;插槽命名，
          &lt;/header&gt;
          &lt;main&gt;
            &lt;slot&gt;&lt;/slot&gt;
          &lt;/main&gt;
          &lt;footer&gt;
            &lt;slot name=&#39;footer&#39;&gt;&lt;/slot&gt;
          &lt;/footer&gt;
        &lt;/div&gt;
      `
    });</code></pre>
<h5 id="3、作用域插槽用法"><a href="#3、作用域插槽用法" class="headerlink" title="3、作用域插槽用法"></a>3、作用域插槽用法</h5><pre><code class="JavaScript">//让插槽内容能够访问子组件中才有的数据是很有用的。
&lt;div id=&#39;app&#39;&gt;  //调用组件
        &lt;father :arr=&#39;arr&#39;&gt;  //将父组件的arr传递给father组件
           //通过slot-scope方法将slot插槽获取的info存入slotProps,
          //在 &lt;template&gt; 上使用特殊的 slot-scope 特性，可以接收传递给插槽的参数，这里使用了绑定属性
            &lt;template slot-scope=&#39;slotProps&#39; slot=&#39;main&#39;&gt;  
                &lt;span&gt;{{slotProps.info.name}}&lt;/span&gt;
            &lt;/template&gt;
        &lt;/father&gt;
    &lt;/div&gt;
    //创建father组件,
Vue.component(&#39;father&#39;,{
            props:[&#39;arr&#39;], //通过father组件的props接收arr
            data(){},
            template:`&lt;div&gt;
                &lt;main&gt;
                    &lt;div :key=&#39;item.id&#39; v-for=&#39;item in arr&#39;&gt;   //arr获取的每一项item传递给slot
                    &lt;slot name=&#39;main&#39; :info=&#39;item&#39;&gt;{{item.name}}&lt;/slot&gt;  
                    &lt;/div&gt;
                &lt;/main&gt;
            &lt;/div&gt;`
        })</code></pre>
<h4 id="12、Promise用法"><a href="#12、Promise用法" class="headerlink" title="12、Promise用法"></a>12、Promise用法</h4><h5 id="1、传统异步编程思维"><a href="#1、传统异步编程思维" class="headerlink" title="1、传统异步编程思维"></a>1、传统异步编程思维</h5><pre><code>javascript是单线程的，所以需要依靠异步执行回调函数来实现
传统意义上，ajax是异步的，如果要实现依赖关系，就必须嵌套，否则不按照顺序执行
这样嵌套多了，代码就会越来越复杂，可读性差</code></pre><h5 id="2、Promise函数概述"><a href="#2、Promise函数概述" class="headerlink" title="2、Promise函数概述"></a>2、Promise函数概述</h5><pre><code class="html">也就是先执行ajax逻辑，最后通过成功或者失败来调用相应的函数
Promise是异步编程的一种解决方案，
好处：避免多层异步调用嵌套
Promise对象提供了API

Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject.

    resolve函数的作用是，将 Promise 对象的状态从 未处理 变成 处理成功 (unresolved =&gt; resolved)， 在异步操作成功时调用，并将异步操作的结果作为参数传递出去。

    reject函数的作用是，将 Promise 对象的状态从 未处理 变成 处理失败 (unresolved =&gt; rejected), 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
    Promise 实例生成以后，可以用 then 方法的两个回调函数指定 resolved 状态和 rejected 状态的回调函数。</code></pre>
<h5 id="3、Promise使用"><a href="#3、Promise使用" class="headerlink" title="3、Promise使用"></a>3、Promise使用</h5><pre><code class="javascript">实例化，两个回调函数，resole成功执行，reject失败执行
var p=new Promise(function(resolve,reject){
  var flag=true
  if(flag){
    reslove(&#39;hello&#39;)  //成功执行的函数，传参
  }else{
    reject(&#39;出错了&#39;)  //失败执行的函数，传参
  }
})
实例对象的then方法，传入两个实参(函数) data/info 是上面执行函数的传参
p.then(function(data){},function(info){})</code></pre>
<p>​    4、Promise的实现</p>
<pre><code class="JavaScript">//通过then，可以实现异步函数安装一定的顺序执行
// 0.5秒后返回input*input的计算结果:
function multiply(input) {
    return new Promise(function (resolve, reject) {
        log(&#39;calculating &#39; + input + &#39; x &#39; + input + &#39;...&#39;);
        setTimeout(resolve, 500, input * input);
    });
}

// 0.5秒后返回input+input的计算结果:
function add(input) {
    return new Promise(function (resolve, reject) {
        log(&#39;calculating &#39; + input + &#39; + &#39; + input + &#39;...&#39;);
        setTimeout(resolve, 500, input + input);
    });
}
var p = new Promise(function (resolve, reject) {
    log(&#39;start new Promise...&#39;);
    resolve(123);
});
p.then(multiply)
 .then(add)
 .then(multiply)
 .then(add)
 .then(function (result) {
    log(&#39;Got value: &#39; + result);  
});
Log:  //打印结果
start new Promise...
calculating 123 x 123...
calculating 15129 + 15129...
calculating 30258 x 30258...
calculating 915546564 + 915546564...
Got value: 1831093128</code></pre>
<h4 id="13Promise常用API"><a href="#13Promise常用API" class="headerlink" title="13Promise常用API"></a>13Promise常用API</h4><p>​    Promise.all()</p>
<pre><code>Promise.all([p1,p2])方法接受一个数组做参数，数组对象p1,p2都是Promise的实例对象，得到的是三个返回值
（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定</code></pre><p>​    Promise.race()</p>
<pre><code>Promise.race方法同样接受一个数组作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数</code></pre><h5 id="2、fetch"><a href="#2、fetch" class="headerlink" title="2、fetch"></a>2、fetch</h5><p>Fetch API是新的ajax解决方案 Fetch会返回Promise</p>
<ul>
<li><strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。</li>
<li>fetch(url, options).then(）</li>
</ul>
<h5 id="3、axios"><a href="#3、axios" class="headerlink" title="3、axios"></a>3、axios</h5><blockquote>
<p>axios是一个基于promise的请求库,可以在node环境和浏览器环境中使用。</p>
</blockquote>
<ol>
<li>引入axios</li>
</ol>
<pre><code class="js">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>全局的 axios 默认值</p>
<pre><code>//设置基准请求路径
axios.defaults.baseURL = &#39;https://api.example.com&#39;;  
//设置请求头
axios.defaults.headers.common[&#39;Authorization&#39;] = AUTH_TOKEN;
axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;;
</code></pre><p>get请求</p>
<pre><code class="js"> # 2.1  通过传统的url  以 ? 的形式传递参数
    axios.get(&#39;http://localhost:3000/axios?id=123&#39;).then(function(ret){
      console.log(ret.data)
    })
 # 2.2  restful 形式传递参数 
    axios.get(&#39;http://localhost:3000/axios/123&#39;).then(function(ret){
      console.log(ret.data)
    })
# 2.3  通过params  形式传递参数 
    axios.get(&#39;http://localhost:3000/axios&#39;, {
      params: {
        id: 789
      }
    }).then(function(ret){
      console.log(ret.data)
    })</code></pre>
<p>delete请求</p>
<pre><code>axios delete 请求传参     传参的形式和 get 请求一样
    axios.delete(&#39;http://localhost:3000/axios&#39;, {
      params: {
        id: 111
      }
    }).then(function(ret){
      console.log(ret.data)
    })</code></pre><p>post请求</p>
<pre><code class="js"> # 4.1  通过选项传递参数
    axios.post(&#39;http://localhost:3000/axios&#39;, {
      uname: &#39;lisi&#39;,
      pwd: 123
    }).then(function(ret){
      console.log(ret.data)
    })
    # 4.2  通过 URLSearchParams  传递参数 
    var params = new URLSearchParams();
    params.append(&#39;uname&#39;, &#39;zhangsan&#39;);
    params.append(&#39;pwd&#39;, &#39;111&#39;);
    axios.post(&#39;http://localhost:3000/axios&#39;, params).then(function(ret){
      console.log(ret.data)
    })

获取当前地址栏的指定参数，比如id
//new URlSearchParams(location.search).get(&#39;id&#39;)
</code></pre>
<p>put请求</p>
<pre><code>#5  axios put 请求传参   和 post 请求一样 
    axios.put(&#39;http://localhost:3000/axios/123&#39;, {
      uname: &#39;lisi&#39;,
      pwd: 123
    }).then(function(ret){
      console.log(ret.data)
    })</code></pre><h5 id="4、axios拦截器"><a href="#4、axios拦截器" class="headerlink" title="4、axios拦截器"></a>4、axios拦截器</h5><p><a href="http://www.axios-js.com/zh-cn/docs/" target="_blank" rel="noopener">http://www.axios-js.com/zh-cn/docs/</a></p>
<pre><code class="javascript">//在请求或响应被 then 或 catch 处理前拦截它们。每次客户端请求或者服务端响应都要拦截处理
// 添加请求拦截器
axios.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    return config;
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  });

// 添加响应拦截器
axios.interceptors.response.use(function (response) {
    // 对响应数据做点什么
    return response;
  }, function (error) {
    // 对响应错误做点什么
    return Promise.reject(error);
  });</code></pre>
<h5 id="5、async和await"><a href="#5、async和await" class="headerlink" title="5、async和await"></a>5、async和await</h5><pre><code>- async作为一个关键字放到函数前面
  - 任何一个async函数都会隐式返回一个promise
- await关键字只能在使用async定义的函数中使用
  -     await后面可以直接跟一个 Promise实例对象
  -      await函数不能单独使用
- async/await 让异步代码看起来、表现起来更像同步代码</code></pre><h5 id="14、路由"><a href="#14、路由" class="headerlink" title="14、路由"></a>14、路由</h5><blockquote>
<p>后端路由:监听不同的URI(地址),做不同的请求处理</p>
</blockquote>
<blockquote>
<p>前端路由:是专门为SPA(单页应用程序)服务,也是监听不同的地址,做页面的切换</p>
<p>模拟路由</p>
</blockquote>
<pre><code> &lt;!-- 根据 :is 属性指定的组件名称，把对应的组件渲染到 component 标签所在的位置 --&gt;
      &lt;!-- 可以把 component 标签当做是【组件的占位符】 --&gt;
      &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;
       // #region 定义需要被切换的 4 个组件
      // 主页组件
      const zhuye = {
        template: &#39;&lt;h1&gt;主页信息&lt;/h1&gt;&#39;
      }

      // 科技组件
      const keji = {
        template: &#39;&lt;h1&gt;科技信息&lt;/h1&gt;&#39;
      }

      // 财经组件
      const caijing = {
        template: &#39;&lt;h1&gt;财经信息&lt;/h1&gt;&#39;
      }

      // 娱乐组件
      const yule = {
        template: &#39;&lt;h1&gt;娱乐信息&lt;/h1&gt;&#39;
      }
      // 注册私有组件
        components: {
          zhuye,
          keji,
          caijing,
          yule
        }</code></pre><h5 id="1、路由使用"><a href="#1、路由使用" class="headerlink" title="1、路由使用"></a>1、路由使用</h5><pre><code class="javascript">&lt;div id=&quot;app&quot;&gt;
  &lt;h1&gt;Hello App!&lt;/h1&gt;
  &lt;p&gt;
    &lt;!-- 使用 router-link 组件来导航. --&gt;
    &lt;!-- 通过传入 `to` 属性指定链接. --&gt;
    &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;
    &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;
    &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;
  &lt;/p&gt;
  &lt;!-- 路由出口 --&gt;
  &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;
// 1. 定义 (路由) 组件。
// 可以从其他文件 import 进来
const Foo = { template: &#39;&lt;div&gt;foo&lt;/div&gt;&#39; }
const Bar = { template: &#39;&lt;div&gt;bar&lt;/div&gt;&#39; }

// 2. 定义路由
// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是
// 通过 Vue.extend() 创建的组件构造器，
// 或者，只是一个组件配置对象。
// 我们晚点再讨论嵌套路由。
const routes = [
  { path: &#39;/foo&#39;, component: Foo },
  { path: &#39;/bar&#39;, component: Bar }
]

// 3. 创建 router 实例，然后传 `routes` 配置
// 你还可以传别的配置参数, 不过先这么简单着吧。
const router = new VueRouter({
  routes // (缩写) 相当于 routes: routes
})

// 4. 创建和挂载根实例。
// 记得要通过 router 配置参数注入路由，
// 从而让整个应用都有路由功能
new Vue({
    el:&#39;#app&#39;,
    // 将vuerouter对象注册到Vue内部,以保证在托管区域中可以使用VueRouter内部提供的组件以及其他属性和方法
    router:router
})</code></pre>
<h5 id="2、路由嵌套"><a href="#2、路由嵌套" class="headerlink" title="2、路由嵌套"></a>2、路由嵌套</h5><pre><code>//register组件里面写跳转标签router-link
const Register={
            template:`&lt;div&gt;,
                &lt;h1&gt;注册组件&lt;/h1&gt;
                &lt;hr/&gt;
                &lt;router-link to=&#39;/register/tab1&#39;&gt;tab1&lt;/router-login&gt;
                &lt;router-link to=&#39;/register/tab2&#39;&gt;tab2&lt;/router-login&gt;
                &lt;router-view /&gt; //填充子组件
            &lt;/div&gt;`
        }
        //创建register组件要跳转的的子组件
const Tab1={
            template:&#39;&lt;h3&gt;tab1子组件&lt;/h3&gt;&#39;
        }
        const Tab2={
            template:&#39;&lt;h3&gt;tab2子组件&lt;/h3&gt;&#39;
        }    
const router = new VueRouter({
 // 所有的路由规则 ，在register规则中通过children数组中继续嵌套路由规则，跳转子组件
          routes: [
              { path: &#39;/&#39;, redirect: &#39;/login&#39; },
            { path: &#39;/login&#39;, component: User },
            { path: &#39;/register&#39;, component: Register ,children:[
                { path: &#39;/register/tab1&#39;, component: Tab1 },
                { path: &#39;/register/tab2&#39;, component: Tab2 }
            ]}
          ]
        })</code></pre><h5 id="3、动态匹配路由"><a href="#3、动态匹配路由" class="headerlink" title="3、动态匹配路由"></a>3、动态匹配路由</h5><p>1、$route.params.id</p>
<pre><code>&lt;div id=&#39;app&#39;&gt;
        //通过传递id,模板中$route.params.id来接收id值
        &lt;router-link to=&quot;/user/1&quot;&gt;user1&lt;/router-link&gt;   
        &lt;router-link to=&quot;/user/2&quot;&gt;user2&lt;/router-link&gt;
        &lt;router-link to=&quot;/user/3&quot;&gt;user3&lt;/router-link&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
const User = {
  template: &#39;&lt;div&gt;User {{ $route.params.id }}&lt;/div&gt;&#39;
}
const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头
    { path: &#39;/user/:id&#39;, component: User }     
  ]
})
</code></pre><p>2、props:true</p>
<pre><code>通过链接传值，路由开启props:true,组件的props接收参数，传递给组件模板
&lt;div id=&#39;app&#39;&gt;
        &lt;router-link to=&quot;/user/1&quot;&gt;user1&lt;/router-link&gt;
        &lt;router-link to=&quot;/user/2&quot;&gt;user2&lt;/router-link&gt;
        &lt;router-link to=&quot;/user/3&quot;&gt;user3&lt;/router-link&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;

        const user={
            props:[&#39;id&#39;],
            template:&#39;&lt;div&gt;user组件---{{id}}&lt;/div&gt;&#39;
        }
        var router=new VueRouter({
            routes:[
                {path:&#39;/user/:id&#39;,component:user,props:true}
            ]
        })

        可以这样传递多个参数，props来接收
        &lt;router-link to=&quot;/user/1/jack&quot;&gt;user1&lt;/router-link&gt;
        {path:&#39;/user/:id/:uname&#39;,component:user,props:true}</code></pre><p>3， { path: ‘/user/:id’, component: User, props: { uname: ‘lisi’, age: 20 } }</p>
<p>此方法，路由可以传递多个参数</p>
<p>props:[‘id’,’age’,’uname’],接收多个参数 ，但是id就失去作用了</p>
<p>4、props: route =&gt; ({ uname: ‘zs’, age: 20, id: route.params.id })  传递多个参数</p>
<pre><code>通过hash地址指向路由，路由接收id，并通过props
routes: [
          { path: &#39;/&#39;, redirect: &#39;/user&#39; },
          {
            path: &#39;/user/:id&#39;,
            component: User,
            props: route =&gt; ({ uname: &#39;zs&#39;, age: 20, id: route.params.id })
          },
        ]</code></pre><p>5、命名路由</p>
<pre><code>to需要属性动态绑定  ：to
&lt;router-link :to=&quot;{name:&#39;user&#39;,params:{id:3}}&quot;&gt;user3&lt;/router-link&gt; 
var router = new VueRouter({
                routes: [{
                    name:&#39;user&#39;,
                    path: &#39;/user/:id&#39;,
                    component: user,
                    props: route =&gt; ({
                        uname: &#39;jack&#39;,
                        id: route.params.id
                    })
                }]
            })    </code></pre><p>4、路由组件传参  ？？？</p>
<pre><code> 1,$route.params.id 捕获router路由的路径传参，但是在组件中使用 $route 会使之与其对应路由形成高度耦合
 2、使用props解耦，也能得到参数，想要在组件中通过props获得参数，必须在每个路由path中添加props用于开启props  ， 这样你便可以在任何地方使用该组件
 布尔模式：props:true,</code></pre><p>5、编程式导航</p>
<pre><code>声明式 &lt;router-link :to=&quot;...&quot;&gt;    
编程式 router.push(...)
想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。
在Vue内部，可以调用this.$router.push(&#39;/register&#39;)，来跳转
                this.$router.go(-1)，后退一步
                router.go(1) 前进一步</code></pre>
            </div>
            <hr/>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff;
        background-color: #22AB38;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff;
        background-color: #019FE8;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a class="reward-link btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs">
                        <li class="tab wechat-tab waves-effect waves-light"><a class="active" href="#wechat">微信</a></li>
                        <li class="tab alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                    </ul>
                    <div id="wechat">
                        <img src="/hexo_blog/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                    <div id="alipay">
                        <img src="/hexo_blog/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('#reward .reward-link').on('click', function () {
            $('#rewardModal').openModal();
        });

        $('#rewardModal .close').on('click', function () {
            $('#rewardModal').closeModal();
        });
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/hexo_blog/libs/share/css/share.min.css">

<div id="article-share">
  
  <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
  
</div>

<script src="/hexo_blog/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="http://yanyufanchen.gitee.io/hexo_blog" class="b-link-green">Wang peng's blog</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/hexo_blog/2019/10/13/vue_study/" class="b-link-green">前端最好用的框架-Vue</a>
                </p>
            </div>
        </div>
    </div>

    

    

    

    

    
        <style>
  .valine-card {
    margin: 1.5rem auto;
  }

  .valine-card .card-content {
    padding: 20px 20px 5px 20px;
  }

  #vcomments input[type=text],
  #vcomments input[type=email],
  #vcomments input[type=url],
  #vcomments textarea {
    box-sizing: border-box;
  }

  #vcomments p {
    margin: 2px 2px 10px;
    font-size: 1.05rem;
    line-height: 1.78rem;
  }

  #vcomments blockquote p {
    text-indent: 0.2rem;
  }

  #vcomments a {
    padding: 0 2px;
    color: #42b983;
    font-weight: 500;
    text-decoration: underline;
  }

  #vcomments img {
    max-width: 100%;
    height: auto;
    cursor: pointer;
  }

  #vcomments ol li {
    list-style-type: decimal;
  }

  #vcomments ol,
  ul {
    display: block;
    padding-left: 2em;
    word-spacing: 0.05rem;
  }

  #vcomments ul li,
  ol li {
    display: list-item;
    line-height: 1.8rem;
    font-size: 1rem;
  }

  #vcomments ul li {
    list-style-type: disc;
  }

  #vcomments ul ul li {
    list-style-type: circle;
  }

  #vcomments table,
  th,
  td {
    padding: 12px 13px;
    border: 1px solid #dfe2e5;
  }

  #vcomments table,
  th,
  td {
    border: 0;
  }

  table tr:nth-child(2n),
  thead {
    background-color: #fafafa;
  }

  #vcomments table th {
    background-color: #f2f2f2;
    min-width: 80px;
  }

  #vcomments table td {
    min-width: 80px;
  }

  #vcomments h1 {
    font-size: 1.85rem;
    font-weight: bold;
    line-height: 2.2rem;
  }

  #vcomments h2 {
    font-size: 1.65rem;
    font-weight: bold;
    line-height: 1.9rem;
  }

  #vcomments h3 {
    font-size: 1.45rem;
    font-weight: bold;
    line-height: 1.7rem;
  }

  #vcomments h4 {
    font-size: 1.25rem;
    font-weight: bold;
    line-height: 1.5rem;
  }

  #vcomments h5 {
    font-size: 1.1rem;
    font-weight: bold;
    line-height: 1.4rem;
  }

  #vcomments h6 {
    font-size: 1rem;
    line-height: 1.3rem;
  }

  #vcomments p {
    font-size: 1rem;
    line-height: 1.5rem;
  }

  #vcomments hr {
    margin: 12px 0;
    border: 0;
    border-top: 1px solid #ccc;
  }

  #vcomments blockquote {
    margin: 15px 0;
    border-left: 5px solid #42b983;
    padding: 1rem 0.8rem 0.3rem 0.8rem;
    color: #666;
    background-color: rgba(66, 185, 131, .1);
  }

  #vcomments pre {
    font-family: monospace, monospace;
    padding: 1.2em;
    margin: .5em 0;
    background: #272822;
    overflow: auto;
    border-radius: 0.3em;
    tab-size: 4;
  }

  #vcomments code {
    font-family: monospace, monospace;
    padding: 1px 3px;
    font-size: 0.92rem;
    color: #e96900;
    background-color: #f8f8f8;
    border-radius: 2px;
  }

  #vcomments pre code {
    font-family: monospace, monospace;
    padding: 0;
    color: #e8eaf6;
    background-color: #272822;
  }

  #vcomments pre[class*="language-"] {
    padding: 1.2em;
    margin: .5em 0;
  }

  #vcomments code[class*="language-"],
  pre[class*="language-"] {
    color: #e8eaf6;
  }

  #vcomments [type="checkbox"]:not(:checked),
  [type="checkbox"]:checked {
    position: inherit;
    margin-left: -1.3rem;
    margin-right: 0.4rem;
    margin-top: -1px;
    vertical-align: middle;
    left: unset;
    visibility: visible;
  }

  #vcomments b,
  strong {
    font-weight: bold;
  }

  #vcomments dfn {
    font-style: italic;
  }

  #vcomments small {
    font-size: 85%;
  }

  #vcomments cite {
    font-style: normal;
  }

  #vcomments mark {
    background-color: #fcf8e3;
    padding: .2em;
  }

  #vcomments table,
  th,
  td {
    padding: 12px 13px;
    border: 1px solid #dfe2e5;
  }

  table tr:nth-child(2n),
  thead {
    background-color: #fafafa;
  }

  #vcomments table th {
    background-color: #f2f2f2;
    min-width: 80px;
  }

  #vcomments table td {
    min-width: 80px;
  }

  #vcomments [type="checkbox"]:not(:checked),
  [type="checkbox"]:checked {
    position: inherit;
    margin-left: -1.3rem;
    margin-right: 0.4rem;
    margin-top: -1px;
    vertical-align: middle;
    left: unset;
    visibility: visible;
  }
</style>

<div class="card valine-card" data-aos="fade-up">
  <div id="vcomments" class="card-content"></div>
</div>

<script src="/hexo_blog/libs/valine/av-min.js"></script>
<script src="/hexo_blog/libs/valine/Valine.min.js"></script>
<script>
  new Valine({
    el: '#vcomments',
    appId: '',
    appKey: '',
    notify: 'false' === 'true',
    verify: 'false' === 'true',
    visitor: 'true' === 'true',
    avatar: 'mm',
    pageSize: '10',
    lang: 'zh-cn',
    placeholder: 'just go go'
  });
</script>
    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-dot-circle-o"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/hexo_blog/2019/10/13/vue_study/">
                    <div class="card-image">
                        
                        <img src="/hexo_blog/images/vue.jpg" class="responsive-img" alt="前端最好用的框架-Vue">
                        
                        <span class="card-title">前端最好用的框架-Vue</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">1、前端三大框架angular(google)—-react(facebook)—–vue（尤雨溪）
2014年发布，2016年升级2.0
Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架
Vue.js </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-10-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/hexo_blog/categories/前端开发/" class="post-category" target="_blank">
                                    前端开发
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/hexo_blog/tags/Vue/" target="_blank">
                        <span class="chip bg-color">Vue</span>
                    </a>
                    
                    <a href="/hexo_blog/tags/框架/" target="_blank">
                        <span class="chip bg-color">框架</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/hexo_blog/2019/10/13/node_study/">
                    <div class="card-image">
                        
                        <img src="/hexo_blog/images/node2.png" class="responsive-img" alt="Nodejs后端语言学习">
                        
                        <span class="card-title">Nodejs后端语言学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">·Node.js增删改查文件以及模块化一语言和环境之间的关系前端 和 后端​    前端主要工作

页面结构
美化页面样式
书写页面的业务逻辑
使用Ajax调用后台接口


后端主要工作

操作数据库
对外暴露操作数据库的API接口


前</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-10-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/hexo_blog/categories/后端开发/" class="post-category" target="_blank">
                                    后端开发
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/hexo_blog/tags/node-js/" target="_blank">
                        <span class="chip bg-color">node.js</span>
                    </a>
                    
                    <a href="/hexo_blog/tags/环境/" target="_blank">
                        <span class="chip bg-color">环境</span>
                    </a>
                    
                    <a href="/hexo_blog/tags/脚本语言/" target="_blank">
                        <span class="chip bg-color">脚本语言</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: Wang peng's blog<br />'
            + '作者: Peng Wang<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>

    </div>
    <div class="col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<script src="/hexo_blog/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>
    

</main>


  <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">19.6k</span>
            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/yanyufanchen" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:592394158@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=592394158" class="tooltipped" data-tooltip="QQ联系我: 592394158" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


</div>
    </div>
</footer>

<div class="progress-bar"></div>


  <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
  <div class="modal-content">
    <div class="search-header">
      <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
      <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"
        autofocus="">
    </div>
    <div id="searchResult"></div>
  </div>
</div>

<script src="/hexo_blog/js/search.js"></script>
<script type="text/javascript">
  searchFunc("/hexo_blog/" + "search.xml", 'searchInput', 'searchResult');
</script>
  <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


  <script src="/hexo_blog/libs/materialize/js/materialize.min.js"></script>
  <script src="/hexo_blog/libs/masonry/masonry.pkgd.min.js"></script>
  <script src="/hexo_blog/libs/aos/aos.js"></script>
  <script src="/hexo_blog/libs/scrollprogress/scrollProgress.min.js"></script>
  <script src="/hexo_blog/libs/lightGallery/js/lightgallery-all.min.js"></script>
  <script src="/hexo_blog/js/matery.js"></script>

  <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>


  
  <script src="/hexo_blog/libs/others/clicklove.js"></script>
  
  
  <script async src="/hexo_blog/libs/others/busuanzi.pure.mini.js"></script>
  

</body>

</html>